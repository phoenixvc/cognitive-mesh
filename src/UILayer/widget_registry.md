# Cognitive Mesh – **Widget Registry**

> **Purpose**\
> The Widget Registry is the single source‑of‑truth for every UI‐level extension inside the Cognitive Mesh. It stores the *metadata contract* that lets the UI Layer discover, authorise, install and lifecycle‑manage widgets in a secure, governed, marketplace‑like flow.

---

## 1  Registry Principles

| Principle                | Description                                                                                           |
| ------------------------ | ----------------------------------------------------------------------------------------------------- |
| **Signed & Versioned**   | Every widget entry is cryptographically signed and SemVer‑tagged (e.g. `v1.2.0`).                     |
| **RBAC‑Aware**           | Visibility is filtered by the caller’s role(s) and licence tier.                                      |
| **Sandbox‑First**        | A widget’s runtime is sandboxed; the registry only exposes contract metadata – never executable code. |
| **Audit‑Trail Native**   | Publish, update, revoke and deprecate operations emit immutable audit events.                         |
| **Backwards Compatible** | Widgets can declare *breaking* vs *non‑breaking* updates so dashboards auto‑migrate safely.           |

---

## 2  Registry Schema (v0.9)

```jsonc
{
  "widgetId"      : "string",          // globally unique, kebab‑case
  "displayName"   : "string",          // human‑friendly label
  "description"   : "string",          // ≤140 chars summary
  "version"       : "semver",          // 1.2.0 etc.
  "licenseTier"   : "Community | Professional | Enterprise",
  "rbacRoles"     : ["roleId", ...],   // e.g. ["Developer","ComplianceAdmin"]
  "platformLayers": ["Foundation","Reasoning",...],
  "bindings"      : [                   // Mesh tool / API bindings
      { "tool": "chatCompletion" },
      { "api" : "/syntheticDataPipeline" }
  ],
  "configSchema"  : { /* JSON‑Schema */ },
  "maintainers"   : ["github:phoenixvc"],
  "sourcePrd"     : "link or slug",    // traceability
  "status"        : "Active | Deprecated | Revoked",
  "signature"     : "base64‑ed25519"   // generated by Marketplace CA
}
```

---

## 3  Current Registry Entries (α‑catalog)

| Widget ID                     | Display Name           | Source PRD / Module   | Version | Tier         | Key Roles                 | Core Bindings                   | Status |
| ----------------------------- | ---------------------- | --------------------- | ------- | ------------ | ------------------------- | ------------------------------- | ------ |
| **prdgen-widget**             | PRD Generator          | PRDGen MCP PRD        | 0.8.0   | Enterprise   | ProductOwner              | `/generatePrd`, `/validatePrd`  | Active |
| **promptopt-widget**          | Prompt Optimizer       | PromptOpt MCP PRD     | 0.7.1   | Professional | PromptEngineer            | `promptQA`, `promptRegistry`    | Active |
| **docrag-widget**             | Doc RAG Q&A            | DocRAG MCP PRD        | 0.6.4   | Professional | Analyst, Developer        | `ragSearch`, `/qa`              | Active |
| **researchgen-orchestrator**  | Research Generator     | ResearchGen MCP PRD   | 0.5.2   | Enterprise   | Researcher                | `multiAgentResearch`            | Active |
| **datameshquery-sql**         | Data Mesh Query        | DataMeshQuery MCP PRD | 0.4.0   | Professional | Analyst                   | `/queryRunner`                  | Active |
| **financialgen-dashboard**    | Financial Insights Gen | FinancialGen MCP PRD  | 0.3.3   | Professional | FinanceLead               | `marketData`, `nlNarrative`     | Active |
| **memoryagent-recall-widget** | Memory Recall Widget   | MemoryAgent MCP PRD   | 0.2.0   | Community    | Developer                 | `saveMemory`, `queryMemory`     | Active |
| **privatemesh-local-chat**    | PrivateMesh Local Chat | PrivateMesh MCP PRD   | 0.1.5   | Enterprise   | PrivacyAdmin, SystemAdmin | `chatCompletion`, `adminStatus` | Active |
| **synthdatagen-admin**        | Synth Data Gen Admin   | SynthDataGen MCP PRD  | 0.1.0   | Community    | QAEngineer, MLEngineer    | `/syntheticDataPipeline`        | Active |

> **Note:** Additional widgets (e.g. NIST RMF, Adaptive Balance, Agentic System) are defined in their respective PRDs and will appear once their Marketplace review passes.

---

## 4  Lifecycle Workflow (Condensed)

1. **Submit →** Developer uploads widget bundle + `WidgetDefinition.json` to the Marketplace.
2. **Automated Scan →** SAST & dependency checks; signature placeholder generated.
3. **Manual Review →** Security + Product admins verify UX, RBAC, compliance.
4. **Sign & Publish →** ed25519 signature attached; entry inserted into this registry with status `Active`.
5. **Install →** `DashboardLayoutService` surfaces widget to users whose roles & licence tiers match.
6. **Update →** New semver published; dashboards perform safe migration if `minor`/`patch`.
7. **Deprecate / Revoke →** Status flips to `Deprecated` (grace period) or `Revoked` (immediate disable) with release notes & CVE links.

---

## 5  Governance & Storage

| Attribute        | Implementation Detail                                                                  |
| ---------------- | -------------------------------------------------------------------------------------- |
| **Backend**      | PostgreSQL table `widget_registry`; JSONB column `definition`; row‑level ACL enforced. |
| **Cache**        | Redis TTL = 5 min for fast dashboard discovery.                                        |
| **Signature CA** | Mesh PKI; root stored in HSM; signer rotates every 30 days.                            |
| **Audit Log**    | All CRUD ops emit `WidgetRegistryEvent` in Foundation Audit Log.                       |

---

## 6  Open Items

1. Should we allow *multi‑widget bundles* under one signature or keep one‑to‑one?
2. Policy for *role re‑mapping* when a customer upgrades licence tier?
3. Backward compatibility matrix for breaking UI/JS framework upgrades.

---

> **Widget Registry v0.9** – draft ready for cross‑layer review. Next step: integrate with PluginOrchestrator for runtime sandbox routing.

